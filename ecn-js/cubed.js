/*Wallet.js - osirem.comCopyright OSIREM LTD (C) 2016www.osirem.com www.qage.org www.geopomp.comThis source is proprietary, and cannot be used, in part or in full withoutthe express permission of the original author. The original author retain therights to use, modify, and/or relicense this code without notice.*/function BiRand(f_Seed, f_Reset){	if(f_Reset == false)		{		this.m_Seed = f_Seed;		}	else		{		this.m_Seed = Math.random();		}			this.m_ProgressCount = 0;	this.m_Value = Math.random();}BiRand.prototype.acGet = function (){	this.m_Value = Math.random() * this.m_Seed;	this.m_Seed = Math.random();	this.m_ProgressCount++;	return this.m_Value;}function BiVector(f_X, f_Y, f_Z){	this.m_X = f_X;	this.m_Y = f_Y;	this.m_Z = f_Z;}BiVector.prototype.mul = function (f_X, f_Y, f_Z){	var f_Result = new BiVector(0.0);	f_Result.m_X = this.m_X * f_X;	f_Result.m_Y = this.m_Y * f_Y;	f_Result.m_Z = this.m_Z * f_Z;	return f_Result;}BiVector.prototype.add = function (f_X, f_Y, f_Z){	var f_Result = new BiVector(0.0);	f_Result.m_X = this.m_X + f_X;	f_Result.m_Y = this.m_Y + f_Y;	f_Result.m_Z = this.m_Z + f_Z;	return f_Result;}BiVector.prototype.sub = function (f_X, f_Y, f_Z){	var f_Result = new BiVector(0.0);	f_Result.m_X = this.m_X - f_X;	f_Result.m_Y = this.m_Y - f_Y;	f_Result.m_Z = this.m_Z - f_Z;	return f_Result;}BiVector.prototype.cross = function (f_V1X, f_V1Y, f_V1Z, f_V2X, f_V2Y, f_V2Z){	this.m_X = f_V1Y * f_V2X - f_V1Z * f_V2Y;	this.m_Y = f_V1Z * f_V2X - f_V1X * f_V2Z;	this.m_Z = f_V1X * f_V2Y - f_V1Y * f_V2X;}BiVector.prototype.dot = function (){	return (this.m_X * this.m_X + this.m_Y * this.m_Y + this.m_Z * this.m_Z);}BiVector.prototype.acLength = function (){	var f_Length = Math.sqrt(this.dot());	return f_Length;}BiVector.prototype.acPushRandSphere = function (f_Radius, f_Seed){	f_Radius *= 1.5;		for(var f_Cntr = 0; f_Cntr < 7; f_Cntr++)		{		var f_BiRand = new BiRand(f_Seed, false);		var f_Vector = new BiVector((f_BiRand.acGet() - 0.5) * f_Radius,									(f_BiRand.acGet() - 0.5) * f_Radius, 									(f_BiRand.acGet() - 0.5) * f_Radius);											this.m_X += f_Vector.m_X * f_Radius;		this.m_Y += f_Vector.m_Y * f_Radius;		this.m_Z += f_Vector.m_Z * f_Radius;		}}BiVector.prototype.acNorm = function (){	var len = this.m_X * this.m_X + this.m_Y * this.m_Y + this.m_Z * this.m_Z;	if(len > 0)		{		len = 1.0 / Math.sqrt(len);		this.m_X *= len;		this.m_Y *= len;		this.m_Z *= len;		}}function aabb(){	this._min = new BiVector(-99999.9);	this._max = new BiVector(99999.9);}function MAX(a,b){	if(a > b)		{		return a;		}	else		{		return b;		}}function MIN(a,b){	if(a < b)		{		return a;		}	else		{		return b;		}}aabb.prototype.add = function (f_Vector){	this._min.m_X = MIN(this._min.m_X, f_Vector.m_X);	this._min.m_Y = MIN(this._min.m_Y, f_Vector.m_Y);	this._min.m_Z = MIN(this._min.m_Z, f_Vector.m_Z);	this._max.m_X = MAX(this._max.m_X, f_Vector.m_X);	this._max.m_Y = MAX(this._max.m_Y, f_Vector.m_Y);	this._max.m_Z = MAX(this._max.m_Z, f_Vector.m_Z);}aabb.prototype.collide = function (b){	if(this._min.m_X > b._max.m_X) return false;	if(this._min.m_Y > b._max.m_Y) return false;	if(this._min.m_Z > b._max.m_Z) return false;	if(this._max.m_X < b._min.m_X) return false;	if(this._max.m_Y < b._min.m_Y) return false;	if(this._max.m_Z < b._min.m_Z) return false;	return true;}aabb.prototype.inside = function (p){	if(p.m_X < this._min.m_X || p.m_X > this._max.m_X) return false;	if(p.m_Y < this._min.m_Y || p.m_Y > this._max.m_Y) return false;	if(p.m_Z < this._min.m_Z || p.m_Z > this._max.m_Z) return false;	return true;}aabb.prototype.width = function (){	return this._max.m_X - this._min.m_X;}aabb.prototype.height = function (){	return this._max.m_Y - this._min.m_Y;}aabb.prototype.depth = function (){	return this._max.m_Z - this._min.m_Z;}aabb.prototype.center = function (){	var f_Vector = new BiVector((this._min.m_X + this._max.m_X) * 0.5,								(this._min.m_Y + this._max.m_Y) * 0.5,								(this._min.m_Z + this._max.m_Z) * 0.5);	return f_Vector;}aabb.prototype.volume = function (){	var f_Volume = this.width() * this.height() * this.depth();	return f_Volume;}function CubeBicycle(){	this.m_vec_Vertex = [];	this.m_idx_vec_Vertex = 0;	this.m_vec_Color = [];	this.m_idx_vec_Color = 0;	this.m_vec_Indices = [];	this.m_indexCount = 0;	this.m_Refresh = 0; }CubeBicycle.prototype.avGrow = function(f_Amount){	for(var f_Count = 0; f_Count < this.m_idx_vec_Vertex; f_Count++)		{		this.m_vec_Vertex[f_Count].m_X += f_Amount;		this.m_vec_Vertex[f_Count].m_Y += f_Amount;		this.m_vec_Vertex[f_Count].m_Z += f_Amount;		}}CubeBicycle.prototype.avTranslate = function(f_Vector){	for(var f_Count = 0; f_Count < this.m_idx_vec_Vertex; f_Count++)		{		this.m_vec_Vertex[f_Count].add(f_Vector);		}}function CubeKEY(){	this.m_Link = new CubeBicycle();}CubeKEY.prototype.acAddBicycle = function(f_Bicycle){	this.m_Link = f_Bicycle;}		function CubeTXIN(){	this.m_txid = -1;	this.m_prvtxid = -1;	this.m_prvtxoutid = -1;	this.m_txinid = -1;	this.m_gnshareid = -1;	this.m_vout = "";	this.m_pubkey = "";	this.m_vec_sig = [];	this.m_idx_vec_sig = 0;	this.m_sigstr = "";	this.m_amt = 0.0;}function CubeTXOUT(){	this.m_txid = -1;	this.m_txoutid = -1;	this.m_adrid = -1;	this.m_owner = "";	this.m_pubkey = "";	this.m_txoutamt = 0.0;	this.m_owneramt = 0.0;	this.m_Flag = 0;}function CubeTransaction(){	this.m_vec_txin = [];	this.m_idx_vec_txin = 0;	this.m_vec_txout = [];	this.m_idx_vec_txout = 0;	this.m_Hash = "";	this.m_hdid = "";	this.m_owner = "";	this.m_amt = 0.0;	this.m_txid = -1;	this.m_jobid = -1;	this.m_confirmation = 0;}function CubeTransaction(f_A, f_B, f_amt){	this.m_vec_txin = [];	this.m_idx_vec_txin = 0;	this.m_vec_txout = [];	this.m_idx_vec_txout = 0;	this.m_Hash = "";	this.m_hdid = "";	this.m_owner = "";	this.m_amt = f_amt;	this.m_txid = -1;	this.m_jobid = -1;	this.m_confirmation = 0;		var f_txin = new CubeTXIN();	f_txin.m_vout = f_A;	this.m_vec_txin[this.m_vec_txin++] = f_txin;	var f_txout = new CubeTXOUT();	f_txout.m_owner = f_B;	f_txout.m_txoutamt = f_amt;	f_txout.m_owneramt = f_amt;	this.m_amt = f_amt;	this.m_vec_txout[this.m_vec_txout++] = f_txout;}CubeTransaction.prototype.isValid = function(){	var f_Valid = true;	if(m_idx_vec_txout < 1)		{		return false;		}	if(m_idx_vec_txin != 1)		{		var f_txin = new CubeTXIN();		f_txin.m_vout = "Genesis Tracking";		this.m_vec_txin[this.m_idx_vec_txin++] = f_txin;		}	if(m_vec_txin[0].m_txid == -1)		{		f_Valid = false;		}	if(m_vec_txout[0].m_txid == -1)		{		f_Valid = false;		}	return f_Valid;}CubeTransaction.prototype.acHash = function(){	var f_InputHash = "";	for(var f_x = 0; f_x < this.m_idx_vec_txin; f_x++)		{		f_InputHash += this.m_vec_txin[f_x].m_txid;		f_InputHash += this.m_vec_txin[f_x].m_prvtxid;		f_InputHash += this.m_vec_txin[f_x].m_prvtxoutid;		f_InputHash += this.m_vec_txin[f_x].m_gnshareid;		f_InputHash += this.m_vec_txin[f_x].m_vout;		f_InputHash += this.m_vec_txin[f_x].m_pubkey;		f_InputHash += this.m_vec_txin[f_x].m_sigstr;		}	for(var f_y = 0; f_y < m_idx_vec_txout; f_y++)		{		f_InputHash += this.m_vec_txout[f_y].m_txid;		f_InputHash += this.m_vec_txout[f_y].m_adrid;		f_InputHash += this.m_vec_txout[f_y].m_owner;		f_InputHash += this.m_vec_txout[f_y].m_pubkey;		f_InputHash += this.m_vec_txout[f_y].m_txoutamt;		f_InputHash += this.m_vec_txout[f_y].m_owneramt;		}	//add extra data like status etc.	f_InputHash += this.m_amt;	f_InputHash += this.m_txid;	f_InputHash += this.m_jobid;	f_InputHash += this.m_confirmation;	f_InputHash += this.m_hdid;		var hash = sha256.create();	hash.update(f_InputHash);	this.m_Hash = hash.hex();}/*CubeTransaction.prototype.acGetTXOutsFromTiers = function(){	var f_InputHash = "";		$.post("link-request-getwork-ecn-fast.php", {type: "GWQ_SELECT", query: "SELECT id FROM share WHERE shareledger = '" + f_Hash.m_OutputHash + "'"}, function(data, status)				{				var response = data;				var resultcount = response.resultcount;								console.log("resultcount: " + resultcount);							if(resultcount <= 0)					{					console.log("Inserting share!");										$.post("link-request-getwork-ecn-long-share.php", {type: "GWQ_SHARE", mark: f_Target.m_Mark, jobid: f_JobID, hash: f_Hash.m_OutputHash, owner: "0360ce57376c9433e2a677216e8f5ef14f307b18a71b5c806f508084442ee1f7", bck_red: f_Hesh.m_bckred, bck_green: f_Hesh.m_bckgreen, bck_blue: f_Hesh.m_bckblue}, function(data, status)						{						ag_Wait(3000);	for(var f_x = 0; f_x < this.m_idx_vec_txin; f_x++)		{		f_InputHash += this.m_vec_txin[f_x].m_txid;		f_InputHash += this.m_vec_txin[f_x].m_prvtxid;		f_InputHash += this.m_vec_txin[f_x].m_prvtxoutid;		f_InputHash += this.m_vec_txin[f_x].m_gnshareid;		f_InputHash += this.m_vec_txin[f_x].m_vout;		f_InputHash += this.m_vec_txin[f_x].m_pubkey;		f_InputHash += this.m_vec_txin[f_x].m_sigstr;		}	for(var f_y = 0; f_y < m_idx_vec_txout; f_y++)		{		f_InputHash += this.m_vec_txout[f_y].m_txid;		f_InputHash += this.m_vec_txout[f_y].m_adrid;		f_InputHash += this.m_vec_txout[f_y].m_owner;		f_InputHash += this.m_vec_txout[f_y].m_pubkey;		f_InputHash += this.m_vec_txout[f_y].m_txoutamt;		f_InputHash += this.m_vec_txout[f_y].m_owneramt;		}	//add extra data like status etc.	f_InputHash += this.m_amt;	f_InputHash += this.m_txid;	f_InputHash += this.m_jobid;	f_InputHash += this.m_confirmation;	f_InputHash += this.m_hdid;		var hash = sha256.create();	hash.update(f_InputHash);	this.m_Hash = hash.hex();}*/function ag_Block(f_boolPush){	if(f_boolPush)		{		if(g_Block)			{			while(g_Block)				{				//				}			}		else			{			//			}		}	else		{		//		}}/*function ag_GatherTransactions(f_JobID){	var f_Result = "";		console.log("ag_GatherTransactions");	$.post("link-request-getwork-ecn-fast.php", {type: "GWQ_SELECT", query: "SELECT id, hash, confirmation, jobid FROM transactions WHERE jobid < " + f_JobID}, function(data, status)		{		var response = data;		var result = response.result;		var resultcount = response.resultcount;				//var f_String = JSON.stringify(response)		//console.log("f_String: " + f_String);		if(resultcount > 1)			{			//console.log("Inserting share!");			var f_waywardTxLCount = resultcount;			//assume remote connection for windows			var f_Block = 0;			for(var f_Into = 0; f_Into < resultcount; f_Into++)				{				var f_waywardtxid = result[f_Into].id;				console.log("ECN::Transaction wayward... recovering txid = " + f_waywardtxid);				f_Block++;								$.post("link-request-getwork-ecn-wayward.php", {type: "GWQ_WAYWARD", txid: f_waywardtxid, jobid: f_JobID + 1, block: f_Block}, function(data, status)					{					var response = data;		var result = response.result;		var resultblock = response.block;					if(resultblock > f_waywardCount)						{$.post("link-request-getwork-ecn-fast.php", {type: "GWQ_SELECT", query: "SELECT id, hash, confirmation, jobid FROM transactions WHERE jobid < " + f_JobID + " AND status != -5 AND gnshareid <= 0 AND confirmation < 6"}, function(data, status)		{		var response = data;		var result = response.result;		var resultcount = response.resultcount;				//var f_String = JSON.stringify(response)		//console.log("f_String: " + f_String);		if(resultcount > 1)			{			//console.log("Inserting share!");			var f_waywardTxLCount = resultcount;			//assume remote connection for windows			for(var f_Into = 0; f_Into < resultcount; f_Into++)				{				var f_waywardtxid = result[f_Into].id;								console.log(f_waywardtxid);				console.log("ECN::Transaction wayward... recovering txid = " + f_waywardtxid);				var f_waywardtxvalue = "";				var f_waywardtxfield = "";				var f_waywardtxwhere = "";				f_waywardtxfield, "jobid");				f_waywardtxvalue, "%i", (int)f_JobID + (int)1);				f_waywardtxwhere[0], "id = %i", f_waywardtxid);					char txquery[1000];	sprintf(txquery, "SELECT id, hash, confirmation, owner FROM transactions WHERE jobid = %i AND status != -5", f_JobID);	g_SafeL[0]->acSelectCommand(txquery, 2, false);	int f_TxLCount = g_Schedular[0]->m_Entries[g_Schedular[0]->ac_GetEntry(g_Schedular[0]->m_Entries.size() - 1)].size();	printf("ECN::Stat::: f_TxLCount %i\n", f_TxLCount);	int f_EntrantID_HashBoard = g_Schedular[0]->ac_GetEntry(g_Schedular[0]->m_Entries.size() - 1);	//assume remote connection for windows	if((f_Int) && (f_TxLCount > 0))		{		int f_rotoner = 5;		if(f_TxLCount < f_rotoner)			{			f_rotoner = f_TxLCount;			}		for(int f_roton = 0; f_roton < f_TxLCount; f_roton++) 			{ //assume verified  			bool f_Verified = true;			std::string f_hash = g_Schedular[0]->m_Entries[f_EntrantID_HashBoard][f_roton][1];			printf("f_roton %i hash %s\n", f_roton, f_hash.c_str());			if(true)				{				int f_txid = atoi(g_Schedular[0]->m_Entries[f_EntrantID_HashBoard][f_roton][0].c_str());				int f_conf = atoi(g_Schedular[0]->m_Entries[f_EntrantID_HashBoard][f_roton][2].c_str());				CubeTransaction* f_Transaction = nullptr;				if((f_conf < 6) && (f_rotoner > 0))					{					f_rotoner--;					f_Transaction = ag_getTX(f_txid);					if(f_Transaction->isValid())						{ //genesis share present						if((f_Transaction->m_txin[0]->m_gnshareid > 0) || (f_Transaction->m_txin[0]->m_vout.compare("Genesis Coin") == 0) || (f_Transaction->m_txin[0]->m_vout.compare("Genesis Tracking") == 0))							{							if(f_Transaction->m_txin[0]->m_vout.compare("Genesis Tracking") == 0)								{								for(int f_Rotor = 0; f_Rotor < f_TxLCount; f_Rotor++)									{									int f_TXID = atoi(g_Schedular[0]->m_Entries[f_EntrantID_HashBoard][f_Rotor][0].c_str());									if(f_Transaction->m_txid != f_TXID)										{										std::string f_possibledupeowner = g_Schedular[0]->m_Entries[f_EntrantID_HashBoard][f_Rotor][3];										if(f_possibledupeowner.compare(f_Transaction->m_owner) == 0)											{											CubeTransaction* f_PossDupeTransaction = ag_getTX(f_TXID);											if(f_PossDupeTransaction->isValid())												{												if((f_PossDupeTransaction->m_txin[0]->m_vout.compare("Genesis Tracking") == 0) && (f_PossDupeTransaction->m_confirmation >= 6))													{													f_Verified = false;													f_Rotor = f_TxLCount;													}												}											}										}									}								}							if((f_Transaction->m_txout[0]->m_txoutamt <= 0.0f) || (f_Transaction->m_txout[0]->m_txoutamt > 50.0f))								{								f_Verified = false;								}							}						else							{ //generate coin							for(int f_tro = 0; f_tro < f_Transaction->m_txout.size(); f_tro++)								{								float f_combout = 0.0f; //gathered tx value 								CubeTXOUT* f_txout = f_Transaction->m_txout[f_tro];								f_combout += f_txout->m_txoutamt;#if 0								float f_ecoin_value = ag_OwnerBalance(f_txout->m_owner);								if(f_ecoin_value != f_txout->m_owneramt)									{									f_Verified = false;									}#endif								if(f_tro >= 1)									{									float f_txin_value = ag_OwnerBalance(f_Transaction->m_txin[0]->m_vout);									if(f_combout != f_txin_value)										{										f_Verified = false;										}									}								else									{									if(f_combout != f_Transaction->m_amt)										{										f_Verified = false;										}									}								}							}						if((f_Verified == true) && (f_Transaction->m_txin[0]->m_gnshareid <= 0) && (f_Transaction->m_txin[0]->m_vout.compare("Genesis Coin") != 0) && (f_Transaction->m_txin[0]->m_vout.compare("Genesis Tracking") != 0))							{							//for(int f_helly = 0; f_helly < f_Transaction->m_txin.size(); f_helly++)							//	{								CubeTXIN* f_txin = f_Transaction->m_txin[0];								//f_Verified = true;								f_Verified = ag_VerifyTXIN(f_txin, f_Transaction->m_amt);							//	}							}						}					}				else					{	//if already verified, or ignore suspicious					f_Verified = false;					if(f_conf >= 6)						{						//stack tx hash						f_Result = f_Result + f_hash;						}					}				if(f_Verified == true)					{ //stack tx hash					f_Result = f_Result + f_hash;					f_Transaction->m_confirmation++;					if(f_Transaction->m_confirmation >= 6)						{						if(f_Transaction->isValid())							{							f_Transaction->acHash();							f_Transaction->acUpdateSync();							for(int f_Jet = 0; f_Jet < f_Transaction->m_txout.size(); f_Jet++)								{								switch(f_Jet)									{									case 0:										{										if(f_Transaction->m_txin[0]->m_gnshareid != -2)											{											char* f_balupvalue[1];											char* f_balupfield[1];											char* f_balupwhere[1];											f_balupvalue[0] = (char*)malloc(sizeof(char) * 1024);											f_balupfield[0] = (char*)malloc(sizeof(char) * 1024);											f_balupwhere[0] = (char*)malloc(sizeof(char) * 1024);											CubeTXOUT* f_txout = f_Transaction->m_txout[f_Jet];											float f_OwnerBalance = ag_OwnerBalance(f_txout->m_owner);											float f_finalBalance = f_OwnerBalance + f_txout->m_txoutamt;											sprintf(f_balupfield[0], "amt");											sprintf(f_balupvalue[0], "%f", f_finalBalance);											sprintf(f_balupwhere[0], "owner = '%s'", f_txout->m_owner.c_str());											g_SafeL[0]->Update("address", (const char **)f_balupfield, (const char **)f_balupvalue, 1, f_balupwhere[0], 2, false);											}										}break;									case 1:										{										}break;									}								}							}						//Decided to return here so 1 tx confirmation = 1 share						return f_Result;						}					else						{						char* f_conupvalue[1];						char* f_conupfield[1];						char* f_conupwhere[1];						f_conupvalue[0] = (char*)malloc(sizeof(char) * 1024);						f_conupfield[0] = (char*)malloc(sizeof(char) * 1024);						f_conupwhere[0] = (char*)malloc(sizeof(char) * 1024);						sprintf(f_conupfield[0], "confirmation");						sprintf(f_conupvalue[0], "%i", f_Transaction->m_confirmation);						sprintf(f_conupwhere[0], "id = %i", f_Transaction->m_txid);						g_SafeL[0]->Update("transactions", (const char **)f_conupfield, (const char **)f_conupvalue, 1, f_conupwhere[0], 2, false);						}					return f_Result;					}				else					{					if(f_Transaction)						{						//delete transaction or flag as suspicious						printf("ECN::Transaction failed Verification txid = %i\n", f_txid);						char* f_txfailvalue[1];						char* f_txfailfield[1];						char* f_txfailwhere[1];						f_txfailvalue[0] = (char*)malloc(sizeof(char) * 1024);						f_txfailfield[0] = (char*)malloc(sizeof(char) * 1024);						f_txfailwhere[0] = (char*)malloc(sizeof(char) * 1024);						sprintf(f_txfailfield[0], "status");						sprintf(f_txfailvalue[0], "%i", -5);						sprintf(f_txfailwhere[0], "id = %i", f_Transaction->m_txid);						g_SafeL[0]->Update("transactions", (const char **)f_txfailfield, (const char **)f_txfailvalue, 1, f_txfailwhere[0], 2, false);						}					else						{	//unverified yet to be checked transaction hash of 1						if(f_conf < 6)							{							f_Result = f_Result + "00000000000000000000000000000001";							}						}					}				}			else				{				printf("ECN::Error row invalid gathering transactions...retry please\n");				}			}		return f_Result;		}	else		{\\					}, "json");				//g_SafeL[0]->Update("transactions", (const char **)f_waywardtxfield, (const char **)f_waywardtxvalue, 1, f_waywardtxwhere[0], 2, false);				}			}		}, "json");	$.post("link-request-getwork-ecn-fast.php", {type: "GWQ_SELECT", query: "SELECT id, hash, confirmation, jobid FROM transactions WHERE jobid < " + f_JobID + " AND status != -5 AND gnshareid <= 0 AND confirmation < 6"}, function(data, status)		{		var response = data;		var result = response.result;		var resultcount = response.resultcount;				//var f_String = JSON.stringify(response)		//console.log("f_String: " + f_String);		if(resultcount > 1)			{			//console.log("Inserting share!");			var f_waywardTxLCount = resultcount;			//assume remote connection for windows			for(var f_Into = 0; f_Into < resultcount; f_Into++)				{				var f_waywardtxid = result[f_Into].id;								console.log(f_waywardtxid);				console.log("ECN::Transaction wayward... recovering txid = " + f_waywardtxid);				var f_waywardtxvalue = "";				var f_waywardtxfield = "";				var f_waywardtxwhere = "";				f_waywardtxfield, "jobid");				f_waywardtxvalue, "%i", (int)f_JobID + (int)1);				f_waywardtxwhere[0], "id = %i", f_waywardtxid);					char txquery[1000];	sprintf(txquery, "SELECT id, hash, confirmation, owner FROM transactions WHERE jobid = %i AND status != -5", f_JobID);	g_SafeL[0]->acSelectCommand(txquery, 2, false);	int f_TxLCount = g_Schedular[0]->m_Entries[g_Schedular[0]->ac_GetEntry(g_Schedular[0]->m_Entries.size() - 1)].size();	printf("ECN::Stat::: f_TxLCount %i\n", f_TxLCount);	int f_EntrantID_HashBoard = g_Schedular[0]->ac_GetEntry(g_Schedular[0]->m_Entries.size() - 1);	//assume remote connection for windows	if((f_Int) && (f_TxLCount > 0))		{		int f_rotoner = 5;		if(f_TxLCount < f_rotoner)			{			f_rotoner = f_TxLCount;			}		for(int f_roton = 0; f_roton < f_TxLCount; f_roton++) 			{ //assume verified  			bool f_Verified = true;			std::string f_hash = g_Schedular[0]->m_Entries[f_EntrantID_HashBoard][f_roton][1];			printf("f_roton %i hash %s\n", f_roton, f_hash.c_str());			if(true)				{				int f_txid = atoi(g_Schedular[0]->m_Entries[f_EntrantID_HashBoard][f_roton][0].c_str());				int f_conf = atoi(g_Schedular[0]->m_Entries[f_EntrantID_HashBoard][f_roton][2].c_str());				CubeTransaction* f_Transaction = nullptr;				if((f_conf < 6) && (f_rotoner > 0))					{					f_rotoner--;					f_Transaction = ag_getTX(f_txid);					if(f_Transaction->isValid())						{ //genesis share present						if((f_Transaction->m_txin[0]->m_gnshareid > 0) || (f_Transaction->m_txin[0]->m_vout.compare("Genesis Coin") == 0) || (f_Transaction->m_txin[0]->m_vout.compare("Genesis Tracking") == 0))							{							if(f_Transaction->m_txin[0]->m_vout.compare("Genesis Tracking") == 0)								{								for(int f_Rotor = 0; f_Rotor < f_TxLCount; f_Rotor++)									{									int f_TXID = atoi(g_Schedular[0]->m_Entries[f_EntrantID_HashBoard][f_Rotor][0].c_str());									if(f_Transaction->m_txid != f_TXID)										{										std::string f_possibledupeowner = g_Schedular[0]->m_Entries[f_EntrantID_HashBoard][f_Rotor][3];										if(f_possibledupeowner.compare(f_Transaction->m_owner) == 0)											{											CubeTransaction* f_PossDupeTransaction = ag_getTX(f_TXID);											if(f_PossDupeTransaction->isValid())												{												if((f_PossDupeTransaction->m_txin[0]->m_vout.compare("Genesis Tracking") == 0) && (f_PossDupeTransaction->m_confirmation >= 6))													{													f_Verified = false;													f_Rotor = f_TxLCount;													}												}											}										}									}								}							if((f_Transaction->m_txout[0]->m_txoutamt <= 0.0f) || (f_Transaction->m_txout[0]->m_txoutamt > 50.0f))								{								f_Verified = false;								}							}						else							{ //generate coin							for(int f_tro = 0; f_tro < f_Transaction->m_txout.size(); f_tro++)								{								float f_combout = 0.0f; //gathered tx value 								CubeTXOUT* f_txout = f_Transaction->m_txout[f_tro];								f_combout += f_txout->m_txoutamt;#if 0								float f_ecoin_value = ag_OwnerBalance(f_txout->m_owner);								if(f_ecoin_value != f_txout->m_owneramt)									{									f_Verified = false;									}#endif								if(f_tro >= 1)									{									float f_txin_value = ag_OwnerBalance(f_Transaction->m_txin[0]->m_vout);									if(f_combout != f_txin_value)										{										f_Verified = false;										}									}								else									{									if(f_combout != f_Transaction->m_amt)										{										f_Verified = false;										}									}								}							}						if((f_Verified == true) && (f_Transaction->m_txin[0]->m_gnshareid <= 0) && (f_Transaction->m_txin[0]->m_vout.compare("Genesis Coin") != 0) && (f_Transaction->m_txin[0]->m_vout.compare("Genesis Tracking") != 0))							{							//for(int f_helly = 0; f_helly < f_Transaction->m_txin.size(); f_helly++)							//	{								CubeTXIN* f_txin = f_Transaction->m_txin[0];								//f_Verified = true;								f_Verified = ag_VerifyTXIN(f_txin, f_Transaction->m_amt);							//	}							}						}					}				else					{	//if already verified, or ignore suspicious					f_Verified = false;					if(f_conf >= 6)						{						//stack tx hash						f_Result = f_Result + f_hash;						}					}				if(f_Verified == true)					{ //stack tx hash					f_Result = f_Result + f_hash;					f_Transaction->m_confirmation++;					if(f_Transaction->m_confirmation >= 6)						{						if(f_Transaction->isValid())							{							f_Transaction->acHash();							f_Transaction->acUpdateSync();							for(int f_Jet = 0; f_Jet < f_Transaction->m_txout.size(); f_Jet++)								{								switch(f_Jet)									{									case 0:										{										if(f_Transaction->m_txin[0]->m_gnshareid != -2)											{											char* f_balupvalue[1];											char* f_balupfield[1];											char* f_balupwhere[1];											f_balupvalue[0] = (char*)malloc(sizeof(char) * 1024);											f_balupfield[0] = (char*)malloc(sizeof(char) * 1024);											f_balupwhere[0] = (char*)malloc(sizeof(char) * 1024);											CubeTXOUT* f_txout = f_Transaction->m_txout[f_Jet];											float f_OwnerBalance = ag_OwnerBalance(f_txout->m_owner);											float f_finalBalance = f_OwnerBalance + f_txout->m_txoutamt;											sprintf(f_balupfield[0], "amt");											sprintf(f_balupvalue[0], "%f", f_finalBalance);											sprintf(f_balupwhere[0], "owner = '%s'", f_txout->m_owner.c_str());											g_SafeL[0]->Update("address", (const char **)f_balupfield, (const char **)f_balupvalue, 1, f_balupwhere[0], 2, false);											}										}break;									case 1:										{										}break;									}								}							}						//Decided to return here so 1 tx confirmation = 1 share						return f_Result;						}					else						{						char* f_conupvalue[1];						char* f_conupfield[1];						char* f_conupwhere[1];						f_conupvalue[0] = (char*)malloc(sizeof(char) * 1024);						f_conupfield[0] = (char*)malloc(sizeof(char) * 1024);						f_conupwhere[0] = (char*)malloc(sizeof(char) * 1024);						sprintf(f_conupfield[0], "confirmation");						sprintf(f_conupvalue[0], "%i", f_Transaction->m_confirmation);						sprintf(f_conupwhere[0], "id = %i", f_Transaction->m_txid);						g_SafeL[0]->Update("transactions", (const char **)f_conupfield, (const char **)f_conupvalue, 1, f_conupwhere[0], 2, false);						}					return f_Result;					}				else					{					if(f_Transaction)						{						//delete transaction or flag as suspicious						printf("ECN::Transaction failed Verification txid = %i\n", f_txid);						char* f_txfailvalue[1];						char* f_txfailfield[1];						char* f_txfailwhere[1];						f_txfailvalue[0] = (char*)malloc(sizeof(char) * 1024);						f_txfailfield[0] = (char*)malloc(sizeof(char) * 1024);						f_txfailwhere[0] = (char*)malloc(sizeof(char) * 1024);						sprintf(f_txfailfield[0], "status");						sprintf(f_txfailvalue[0], "%i", -5);						sprintf(f_txfailwhere[0], "id = %i", f_Transaction->m_txid);						g_SafeL[0]->Update("transactions", (const char **)f_txfailfield, (const char **)f_txfailvalue, 1, f_txfailwhere[0], 2, false);						}					else						{	//unverified yet to be checked transaction hash of 1						if(f_conf < 6)							{							f_Result = f_Result + "00000000000000000000000000000001";							}						}					}				}			else				{				printf("ECN::Error row invalid gathering transactions...retry please\n");				}			}		return f_Result;		}	else		{		return "00000000000000000000000000000001";		}*///}//void acSynchronize(void);//void acUpdateSync(void);